<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neural Link: Bio-Reptile v2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --neon-cyan: #00f3ff;
            --neon-green: #0aff0a;
            --dark-bg: #050a0f;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Share Tech Mono', monospace;
            cursor: none; /* Kita ganti cursor custom */
        }

        canvas {
            display: block;
        }

        /* UI Overlay Styles */
        .hud-text {
            text-shadow: 0 0 5px var(--neon-cyan);
        }

        .scan-line {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 5px;
            background: rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 10px var(--neon-cyan);
            animation: scan 3s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes scan {
            0% { top: -10%; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 110%; opacity: 0; }
        }

        #custom-cursor {
            position: fixed;
            width: 20px; height: 20px;
            border: 2px solid var(--neon-green);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            transition: width 0.1s, height 0.1s;
            mix-blend-mode: difference;
        }
        
        .hud-panel {
            background: rgba(5, 10, 15, 0.85);
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <!-- Scanner Effect -->
    <div class="scan-line"></div>
    <div id="custom-cursor"></div>

    <!-- HUD Layer -->
    <div class="fixed top-0 left-0 w-full h-full pointer-events-none p-6 flex flex-col justify-between z-20">
        
        <!-- Top Header -->
        <div class="flex justify-between items-start">
            <div class="hud-panel p-4 rounded-br-2xl border-l-4 border-l-cyan-400">
                <h1 class="text-cyan-400 text-xl font-bold tracking-widest">NEURAL<span class="text-white">LINK</span></h1>
                <div class="text-[10px] text-gray-400 mt-1">SYSTEM: ONLINE_</div>
                <div class="text-[10px] text-gray-400">FPS: <span id="fps-counter" class="text-green-400">60</span></div>
            </div>
            
            <div class="hud-panel p-4 rounded-bl-2xl text-right border-r-4 border-r-emerald-500">
                <div class="text-[10px] text-gray-400 uppercase tracking-widest">Data Harvested</div>
                <div id="score-display" class="text-4xl font-bold text-emerald-400 hud-text">000</div>
            </div>
        </div>

        <!-- Bottom Status -->
        <div class="flex justify-between items-end">
            <div class="hud-panel p-4 rounded-tr-2xl border-b-2 border-cyan-900">
                <div class="text-xs text-cyan-300 mb-1">COORDINATES</div>
                <div id="coords" class="text-xs text-gray-500">X:000 Y:000</div>
            </div>

            <div class="text-center opacity-50 mb-4 animate-pulse">
                <p class="text-[10px] text-cyan-500">CLICK & HOLD TO ENGAGE HYPER-DRIVE</p>
            </div>
        </div>
    </div>

    <canvas id="simulation"></canvas>

    <script>
        /**
         * Cyber-Reptile Engine v2.0
         * "Clean Code" Architecture
         */

        const CONFIG = {
            SEGMENT_COUNT: 24,
            SEGMENT_SPACING: 14,
            BASE_SPEED: 0.12,
            BOOST_SPEED: 0.25,
            COLOR_PRIMARY: '#00f3ff', // Cyan
            COLOR_SECONDARY: '#10b981', // Emerald
            BG_COLOR: '#050a0f'
        };

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            angle() { return Math.atan2(this.y, this.x); }
        }

        class Entity {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
            }
        }

        class Particle extends Entity {
            constructor(x, y, color) {
                super(x, y);
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1.0;
                this.color = color;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                if(this.life <= 0) this.active = false;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        class Leg {
            constructor(parentId, side) {
                this.parentId = parentId;
                this.side = side; // -1 Left, 1 Right
                this.pos = { x: 0, y: 0 };
                this.target = { x: 0, y: 0 };
                this.moving = false;
            }

            update(parent, angle) {
                // Calculate shoulder position
                const shoulderX = parent.x + Math.cos(angle + Math.PI/2 * this.side) * 10;
                const shoulderY = parent.y + Math.sin(angle + Math.PI/2 * this.side) * 10;

                // Calculate ideal foot position
                const reach = 35;
                const idealX = shoulderX + Math.cos(angle + Math.PI/2.5 * this.side) * reach;
                const idealY = shoulderY + Math.sin(angle + Math.PI/2.5 * this.side) * reach;

                // Distance check
                const dist = Math.hypot(this.pos.x - idealX, this.pos.y - idealY);
                
                if (dist > 50 && !this.moving) {
                    this.target = { x: idealX, y: idealY };
                    this.moving = true;
                }

                if (this.moving) {
                    this.pos.x += (this.target.x - this.pos.x) * 0.25;
                    this.pos.y += (this.target.y - this.pos.y) * 0.25;
                    if (Math.hypot(this.pos.x - this.target.x, this.pos.y - this.target.y) < 1) {
                        this.moving = false;
                    }
                }
            }

            draw(ctx, parent, angle) {
                const shoulderX = parent.x + Math.cos(angle + Math.PI/2 * this.side) * 8;
                const shoulderY = parent.y + Math.sin(angle + Math.PI/2 * this.side) * 8;
                
                // Mechanical Leg Draw
                ctx.beginPath();
                ctx.strokeStyle = CONFIG.COLOR_SECONDARY;
                ctx.lineWidth = 2;
                
                // Joint in middle
                const kneeX = (shoulderX + this.pos.x) / 2 + Math.cos(angle) * -10;
                const kneeY = (shoulderY + this.pos.y) / 2 + Math.sin(angle) * -10;
                
                ctx.moveTo(shoulderX, shoulderY);
                ctx.lineTo(kneeX, kneeY);
                ctx.lineTo(this.pos.x, this.pos.y);
                ctx.stroke();

                // Joint Dots
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.pos.x - 1, this.pos.y - 1, 3, 3);
            }
        }

        class CyberReptile {
            constructor(x, y) {
                this.segments = [];
                for(let i=0; i<CONFIG.SEGMENT_COUNT; i++) {
                    this.segments.push({ x: x, y: y, angle: 0, r: 16 - (i*0.5) });
                }
                this.legs = [];
                // Add legs to middle segments
                for(let i=4; i<CONFIG.SEGMENT_COUNT-4; i+=3) {
                    this.legs.push(new Leg(i, -1), new Leg(i, 1));
                }
            }

            update(targetX, targetY, isBoost) {
                // Head Movement
                const head = this.segments[0];
                const dx = targetX - head.x;
                const dy = targetY - head.y;
                const angle = Math.atan2(dy, dx);
                const dist = Math.hypot(dx, dy);

                // Smooth rotation
                head.angle = angle;

                if (dist > 5) {
                    const speed = isBoost ? CONFIG.BOOST_SPEED : CONFIG.BASE_SPEED;
                    head.x += dx * speed;
                    head.y += dy * speed;
                }

                // IK for Body
                for(let i=1; i<this.segments.length; i++) {
                    const prev = this.segments[i-1];
                    const curr = this.segments[i];
                    
                    const angleToPrev = Math.atan2(prev.y - curr.y, prev.x - curr.x);
                    curr.angle = angleToPrev;
                    
                    const targetX = prev.x - Math.cos(angleToPrev) * CONFIG.SEGMENT_SPACING;
                    const targetY = prev.y - Math.sin(angleToPrev) * CONFIG.SEGMENT_SPACING;

                    curr.x += (targetX - curr.x) * 0.6;
                    curr.y += (targetY - curr.y) * 0.6;
                }

                // Update Legs
                this.legs.forEach(leg => leg.update(this.segments[leg.parentId], this.segments[leg.parentId].angle));
            }

            draw(ctx) {
                // Draw Legs First (Background)
                this.legs.forEach(leg => leg.draw(ctx, this.segments[leg.parentId], this.segments[leg.parentId].angle));

                // Draw Spine/Connections
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
                ctx.lineWidth = 10;
                ctx.moveTo(this.segments[0].x, this.segments[0].y);
                for(let i=1; i<this.segments.length; i++) ctx.lineTo(this.segments[i].x, this.segments[i].y);
                ctx.stroke();

                // Draw Segments
                this.segments.forEach((s, i) => {
                    ctx.save();
                    ctx.translate(s.x, s.y);
                    ctx.rotate(s.angle);

                    // Cyber Plate Design
                    ctx.fillStyle = `rgba(5, 20, 30, 0.9)`;
                    ctx.strokeStyle = i === 0 ? CONFIG.COLOR_PRIMARY : CONFIG.COLOR_SECONDARY;
                    ctx.lineWidth = 1.5;

                    // Hexagon-ish Shape
                    ctx.beginPath();
                    const size = s.r;
                    ctx.moveTo(size, 0);
                    ctx.lineTo(size/2, size);
                    ctx.lineTo(-size/2, size);
                    ctx.lineTo(-size, 0);
                    ctx.lineTo(-size/2, -size);
                    ctx.lineTo(size/2, -size);
                    ctx.closePath();
                    
                    ctx.fill();
                    ctx.stroke();

                    // Head Detail
                    if(i === 0) {
                        ctx.fillStyle = CONFIG.COLOR_PRIMARY;
                        // Eyes
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = CONFIG.COLOR_PRIMARY;
                        ctx.fillRect(2, -6, 8, 2);
                        ctx.fillRect(2, 4, 8, 2);
                        ctx.shadowBlur = 0;
                    }

                    // Tech Details on body
                    if(i % 3 === 0 && i !== 0) {
                        ctx.fillStyle = CONFIG.COLOR_SECONDARY;
                        ctx.fillRect(-2, -2, 4, 4);
                    }

                    ctx.restore();
                });
            }
        }

        class Engine {
            constructor() {
                this.canvas = document.getElementById('simulation');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.mouse = { x: this.width/2, y: this.height/2, down: false };
                this.reptile = new CyberReptile(this.width/2, this.height/2);
                this.particles = [];
                this.targets = [];
                this.score = 0;
                this.lastTime = 0;

                this.init();
            }

            init() {
                window.addEventListener('resize', () => this.resize());
                this.resize();

                // Custom Cursor & Input Logic
                const cursor = document.getElementById('custom-cursor');
                const updateInput = (x, y) => {
                    this.mouse.x = x;
                    this.mouse.y = y;
                    cursor.style.left = x + 'px';
                    cursor.style.top = y + 'px';
                    document.getElementById('coords').innerText = `X:${Math.floor(x)} Y:${Math.floor(y)}`;
                };

                document.addEventListener('mousemove', e => updateInput(e.clientX, e.clientY));
                document.addEventListener('mousedown', () => {
                    this.mouse.down = true;
                    cursor.style.width = '15px';
                    cursor.style.height = '15px';
                    cursor.style.backgroundColor = CONFIG.COLOR_PRIMARY;
                });
                document.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                    cursor.style.width = '20px';
                    cursor.style.height = '20px';
                    cursor.style.backgroundColor = 'transparent';
                });
                document.addEventListener('touchmove', e => {
                    e.preventDefault();
                    updateInput(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });
                document.addEventListener('touchstart', () => this.mouse.down = true);
                document.addEventListener('touchend', () => this.mouse.down = false);

                // Spawn initial target
                this.spawnTarget();
                
                requestAnimationFrame(t => this.loop(t));
            }

            resize() {
                this.width = this.canvas.width = window.innerWidth;
                this.height = this.canvas.height = window.innerHeight;
            }

            spawnTarget() {
                this.targets.push({
                    x: Math.random() * (this.width - 100) + 50,
                    y: Math.random() * (this.height - 100) + 50,
                    angle: 0
                });
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
                this.ctx.lineWidth = 1;
                const gridSize = 60;
                const offset = (Date.now() / 50) % gridSize;
                
                for(let x=offset; x<this.width; x+=gridSize) {
                    this.ctx.beginPath(); this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.height); this.ctx.stroke();
                }
                for(let y=offset; y<this.height; y+=gridSize) {
                    this.ctx.beginPath(); this.ctx.moveTo(0,y); this.ctx.lineTo(this.width,y); this.ctx.stroke();
                }
            }

            loop(timestamp) {
                // FPS calc
                const delta = timestamp - this.lastTime;
                this.lastTime = timestamp;
                document.getElementById('fps-counter').innerText = Math.round(1000/delta);

                // Clear with trail effect
                this.ctx.fillStyle = 'rgba(5, 10, 15, 0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.drawGrid();

                // Logic
                this.reptile.update(this.mouse.x, this.mouse.y, this.mouse.down);
                this.reptile.draw(this.ctx);

                // Targets
                this.targets.forEach((t, i) => {
                    t.angle += 0.05;
                    // Draw Data Cube
                    this.ctx.save();
                    this.ctx.translate(t.x, t.y);
                    this.ctx.rotate(t.angle);
                    this.ctx.strokeStyle = CONFIG.COLOR_PRIMARY;
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(-10, -10, 20, 20);
                    // Inner pulse
                    this.ctx.fillStyle = `rgba(0, 243, 255, ${0.5 + Math.sin(t.angle)*0.4})`;
                    this.ctx.fillRect(-5, -5, 10, 10);
                    this.ctx.restore();

                    // Collision
                    const head = this.reptile.segments[0];
                    if(Math.hypot(head.x - t.x, head.y - t.y) < 30) {
                        this.targets.splice(i, 1);
                        this.score += 10;
                        // Animate score text
                        const scoreEl = document.getElementById('score-display');
                        scoreEl.innerText = this.score.toString().padStart(3, '0');
                        scoreEl.classList.remove('text-emerald-400');
                        void scoreEl.offsetWidth; // trigger reflow
                        scoreEl.classList.add('text-emerald-400');

                        // Explosion
                        for(let j=0; j<10; j++) {
                            this.particles.push(new Particle(t.x, t.y, CONFIG.COLOR_PRIMARY));
                        }
                        this.spawnTarget();
                    }
                });

                // Particles
                this.particles.forEach((p, i) => {
                    p.update();
                    p.draw(this.ctx);
                    if(!p.active) this.particles.splice(i, 1);
                });

                // Boost Visuals
                if(this.mouse.down) {
                    if(Math.random() > 0.5) {
                        const head = this.reptile.segments[0];
                        this.particles.push(new Particle(head.x, head.y, CONFIG.COLOR_SECONDARY));
                    }
                }

                requestAnimationFrame(t => this.loop(t));
            }
        }

        // Boot
        window.onload = () => new Engine();

    </script>
</body>
</html>

